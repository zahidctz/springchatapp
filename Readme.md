## Spring Boot WebSocket Chat Appplication

You can checkout the live version of the application at https://spring-ws-chat.herokuapp.com/

![App Screenshot](screenshot.png)

## Requirements

1. Java - 11

2. Maven - 3.x.x

## Steps to Setup

**1. Clone the application**

```bash
git clone https://github.com/gopal1409//spring-boot-websocket-chat-demo.git
`

**2. Build and run the app using maven**

```bash
cd spring-boot-websocket-chat-demo
mvn package
java -jar target/websocket-demo-0.0.1-SNAPSHOT.jar
```

Alternatively, you can run the app directly without packaging it like so -

```bash
mvn spring-boot:run
```

## Learn More

You can find the tutorial for this application on my blog -
2. Defining a docker image with Dockerfile
Go to the application’s root directory and create a new file named Dockerfile.

$ cd spring-boot-websocket-chat-demo
$ touch Dockerfile
Dockerfile is where we define the docker image and specify all the configurations required to run the app. Following is the Dockerfile for our spring boot application -

# Start with a base image containing Java runtime
FROM openjdk:11

# Add Maintainer Info
LABEL maintainer="callicoder@gmail.com"

# Add a volume pointing to /tmp
VOLUME /tmp

# Make port 8080 available to the world outside this container
EXPOSE 8080

# The application's jar file
ARG JAR_FILE=target/websocket-demo-0.0.1-SNAPSHOT.jar

# Add the application's jar to the container
ADD ${JAR_FILE} websocket-demo.jar

# Run the jar file 
ENTRYPOINT ["java","-Djava.security.egd=file:/dev/./urandom","-jar","/websocket-demo.jar"]
The Dockerfile is very simple and declarative. Let’s go through each line of the Dockerfile and understand the details.

FROM: A docker image can use another image available in the docker registry as its base or parent image. In the above example, we use the openjdk:11 image as our base image.

LABEL: The LABEL instruction is used to add metadata to the image. In the above Dockerfile, we have added some info about the maintainer of the image through LABEL instruction.

VOLUME: Volumes are a mechanism to persist data generated by the container on the Host OS, and share directories from the Host OS with the container.

The VOLUME instruction creates a mount point on the container with the specified path. When you run the container, you can specify the directory on the Hot OS to which the given mount point will be mapped to. After that, anything that the container writes to the mounted path is written to the mapped directory on the Host OS.

One of the most common use cases of volumes is to store the log files generated by the container on the Host OS. For example, Let’s say that your application writes log files to a location /var/log/app.log.

You can mount a VOLUME with path /var/log in the Dockerfile, and then specify the directory on the Host OS to which this mount point will be mapped to while running the container. After that, you’ll be able to access the logs from the mapped directory on the Host OS.

In the above Dockerfile, we created a mount point with path /tmp because this is where the spring boot application creates working directories for Tomcat by default. Although it’s not required for this spring boot application because who cares about tomcat directories. But if you want to store stuff like tomcat access logs, then VOLUMES are very useful.

You can learn more about Volumes from the official documentation.

EXPOSE: As the name suggests, this instruction allows you to expose a certain port to the outside world.

ARG: The ARG instruction defines a variable with a default value. You can override the default value of the variable by passing it at build time.

ARG <name>[=<default value>]
Once defined, the variable can be used by the instructions following it.

ADD: The ADD instruction is used to copy new files and directories to the docker image.

ENTRYPOINT: This is where you configure how the application is executed inside the container.

3. Building the Docker image
Now that we have defined the Dockerfile, let’s build a docker image for our application.

Before building the docker image, you need to make sure that you’ve packaged the application in the form of a jar file using maven. You can type the following command from the root directory of the project to package it -

$ mvn clean package
The above command creates a jar file in the target directory of the project.

Let’s now build the docker image by typing the following command -

$ docker build -t spring-boot-websocket-chat-demo .
That’s it. You can now see the list of all the docker images on your system using the following command -

$ docker image ls

REPOSITORY                        TAG                 IMAGE ID            CREATED             SIZE
spring-boot-websocket-chat-demo   latest              30ad8958ac67        22 hours ago        126MB
openjdk                           8-jdk-alpine        224765a6bdbe        3 months ago        102MB
This should display our newly built docker image.

4. Running the docker image
Once you have a docker image, you can run it using docker run command like so -

$ docker run -p 5000:8080 spring-boot-websocket-chat-demo
In the run command, we have specified that the port 8080 on the container should be mapped to the port 5000 on the Host OS.

Once the application is started, you should be able to access it at http://localhost:5000.

The container runs in the foreground, and pressing CTRL + C will stop it. Let’s now see how to run the container in the background.

Running the docker image in the background, in detached mode.
You can use the -d option in docker run command to run the container in the background -

$ docker run -d -p 5000:8080 spring-boot-websocket-chat-demo
1c3528715862a8a8efb712c85bc8ab61f3419c04eb6dc613af76c89846d316e0
The above command starts the container in the background and gives you the container ID. You can see the list of all containers running in your system using the following command -

$ docker container ls

CONTAINER ID        IMAGE                             COMMAND                  CREATED              STATUS              PORTS                            NAMES
1c3528715862        spring-boot-websocket-chat-demo   "java -Djava.securit…"   About a minute ago   Up About a minute   8080/tcp, 0.0.0.0:4000->80/tcp   vigorous_stallman
5. Pushing the docker image to docker hub
Now let’s push the docker image to docker hub so that other people can download and consume our image.

Login with your Docker Id

$ docker login
